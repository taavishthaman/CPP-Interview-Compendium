Arrays and Vectors

1. Linear Search
    Simply run a for loop on an array, if the current element matches the target return that index. If the loop ends
    return -1 indicating that the element was not found.'
    Time Complexity : O(n)
    Space Complexity : O(1)

2. Binary Search
    Keep 2 pointers lo and hi with lo at 0 and hi at the last index of the array. Now find a mid point using (lo+hi)/2.
    Check if the target element is equal to the element at the mid index. If so, return the mid index. If not, check 
    whether the target element is smaller than the mid element or larger. If smaller, search in the left search space by
    reducing the search space by doing hi = mid - 1. If larger, search in the right search space by reducing the search
    space by doing lo = mid + 1. Repeat the algorithm until search space reduces to 0. If the element is not found return
    -1.
    Time Complexity : O(n)
    Space Complexity : O(1)

3. Array Reverse
    Swap every element from the start to the mid of the array with its corresponding element beginning from the end.
    0 with last element, 1 with second last element and so on till the middle of the array.
    Time Complexity : O(n)
    Space Complexity : O(1)

4. Print Subarrays
    Keep two pointers i and j which traverse the array inside a double for loop. Now print all the elements between i
    and j essentailly printing all the subarrays.
    Time Complexity : O(n^3)
    Space Complexity : O(1)

5. Print Pairs
    Use 2 for loops starting from i = 0 and j = i+1. Print all elements at i and j which will essentially print all pairs.
    Time Complexity : O(n^2)

6. Largest Element
    Set largest_so_far to the first element of the array. Now traverse the array from 1 to n-1 and update largest_so_far
    to the current element if current element is larger than largest_so_far. Return largest_so_far after the loop ends.
    Time Complexity : O(n)
    Space Complexity : O(1)

7. Maximum Subarray Sum
    Create a new array dp and set dp[0] to arr[0]. Now run a for loop where dp[i] = max(nums[i], dp[i-1]+nums[i]). Find the
    largest element in the dp array which will be maximum subarray sum.
    Time Complexity : O(n)
    Space Complexity : O(n)

8. Lower Bound
    This involves the use of binary search. Check the mid of the array. If the arr[mid] is <= target, that could be the lower
    bound so update the ans to arr[mid] and search in the right part of the array. If arr[mid] > target search in the
    left part of the array.
    Time Complexity : O(logn)
    Space Complexity : O(1)

9. Sorted Pair Sum
    Keep two pointers i and j at the start and end of the array. Check the abs difference of the sum of these elements
    from the target element. Keep a minimum absolute difference variable and check whether the current abs diff is smaller.
    If it is save the current pair. Now if current pair sum is smaller than target increase i value otherwise decrease
    j value and repeat the process.
    Time Complexity : O(n)
    Space Complexity : O(1)

10. K Rotate
    The optimized way of doing this is, first reverse the entire array. Then reverse the first k elements and then the 
    last (n-k) elements.
    [1,2,3,4,5] and k = 2
    [5,4,3,2,1] (step 1)
    [4,5,3,2,1] (step 2)
    [4,5,1,2,3] (step 3)
    Time Complexity : O(n)
    Space Complexity : O(n)

11. Inbuilt Search
    Use the find method to do a linear search inside array. 
    auto it = find(v.begin(), v.end(), target);
    int index = it - v.begin()

12. Rotate Image
    This problem can be broken down into 2 steps
    First take the transpose of the matrix

    for(int i=0; i<n; i++) {
        for(int j=0; j<n; j++) {
            if(i > j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }

    Then do a columnwise swapping

    for(int i=0; i<n/2; i++) {
        for(int j=0; j<n; j++) {
            swap(matrix[j][i], matrix[j][n-1-i]);
        }
    }

    Time Complexity : O(n^2)
    Space Complexity : O(1)

13. Set matrix zeroes
    First traverse the matrix and store all the pairs of row and cols which are zeroes.
    Now traverse the stored pairs and set each row and col to 0.
    (This however is not the most optimal solution)

    Time Complexity : O((n+m) * (n+m)) (In worst case)
    Space Complexity : O(n*m)

14. Two Sum
    Traverse the array and keep a hash map to keep track of all the visited elements inside the array. If you find an element
    such that another element exists inside the hash map and their sum is equal to target, return their indices.

    Time Complexity : O(n)
    Space Complexity : O(n)

15. Three Sum
    First sort the array, then traverse the array till the third last element and create 2 more pointers start and end
    which check the array for triplets for every outer for loop iteration. For some further optimisation add condition
    if(nums[i] == nums[i-1]) {continue} to avoid unnecessary duplicacy in computation. Add a while loop to the inner
    loop which moves the start and the end pointers to handle this same condition. It must be handled in both outer
    and inner loop.

    Time Complexity : O(n^2)
    Space Complexity : O(n)

16. Largest Mountain
    Traverse the array from 2nd to 2nd last element and find a peak element. Peak element is the element which is greater
    than both its neighbors. Then start running a while loop in left and right directions from that element keeping track 
    of count at every iteration. The count at the end is the length of the mountain, check if the current mountain length
    is greater than the one found so far.

    Time Complexity : O(n)
    Space Complexity : O(1)

17. Longest Consecutive Sequence
    Insert each element inside an unordered set. Now traverse the array and check if the current element starts a chain.
    Current element will start a chain if one lesser than that element does not ecist inside the set. Now once you have
    the beginning of the chain, keep checking for the next element inside the set and keep increasing the count by one.
    The count after the end of the loop is the length of the current chain you found. Update the global chain length with
    that length.

    Time Complexity : O(n)
    Space Complexity : O(n)

18. Rainwater Trapping
    First calculate the maximum till now left heights and store the values inside an array. Similarly calculate maximum
    till now right heights and store them inside an array. Now for each element do min(left, right) - curr_height to get
    the amount of water stored inside the current index. Add them all up and you will have the total water.

    Time Complexity : O(n)
    Space Complexity : O(n)

19. Subarray Sort
    First find the smallest and largest element which are out of order inside the array. Now traverse the array from
    left to right and find the index of element which is greater than the smallest element we found. Similarly traverse
    the array from right to left and find the index of element which is smaller than the largest element we found. These 
    2 indices denote the size of unsorted array that needs to be sorted in order for entire array to be sorted.

    Time Complexity : O(n)
    Space Complexity : O(n)

20. Minimum Swaps
    First create a copy of the array along with its indices in a new pair vector. Now sort this new vector. Now traverse 
    the array and maintain a visited array. If the element is already visited or is in its correct position skip that element.
    Otherwise start a cycle from that index and keep going to the index marked by the second element inside the pair vector
    and keep marking all indices as visited. Keep doing this until you reach the element which is visited. Add steps - 1
    to the total swaps variable you did for this entire routine. Return the total swaps at the end of the program.

    Time Complexity : O(logn) (Because of sorting)
    Space Complexity : O(n)

21. Minimum Difference
    First sort both the arrays. Now keep 2 pointers, one at the beginning of each array. Now keep calculating minimum difference.
    If the element in the first array is smaller increase the index of first array, if index in second array is smaller
    increase the index of second array. Keep calculating minimum difference at every step. Write a routine like the merge function.

    Time Complexity : O(n + m)
    Space Complexity : O(n)

22. Product of Array Except Self
    Create an array and calculate the prefix products for each element. Now keep a product variable initialized to 1 and
    start traversing the array in backwards direction and for every element in the new array mark current index as product
    of product variable and one perevious element in prefix array. Now mark product as product times current element inside
    the original array.

    Time Complexity : O(n)
    Space Complexity : O(n)

23. Min Arrows to burst Balloons (Busy Life)
    First sort the pair array according to the second coordinate in each points. Now save the first interval's end and traverse
    the array from the first index. Now if current start element is smaller than or equal to the previous ending element
    do nothing because all those balloon are overlapping and can be burst with one arrow only, otherwise increase the number 
    of arrows required by one. Return the total arrows required at the end of program.

    Time Complexity : O(n)
    Space Complexity : O(1)


Strings

1. Count Digits and Spaces
    Simply traverse the string and maintain two counts which are count_spaces and count_digits both initialised to 0.
    Whenever a space is encountered i.e current character == ' ' increase the count of spaces by one and whenever a 
    digit is encountered i.e cc >= '0' and cc <= '9' increase the count of digits by one and for letters do cc >= 'a'
    and cc <= 'z' && cc >= 'A' && cc <= 'Z'.

    Time Complexity : O(n)
    Space Complexity : O(1)

2. Find Shortest Path
    First calculate the total displacement in x and y direction. Now create an output empty string and if final x is less
    than 0 that means the movement was in east and if x was greater than 0 movement was in west. Similarly if final y 
    is less than 0 that means movement was in south and otherwise movement was in north.

    Time Complexity : O(n)
    Space Complexity : O(1)

3. Is Palindrome
    Traverse the array from start to middle, compare the ith element with (n-1-i)th element, if they are not equal return
    false. If the loop is terminated return true.

    Time Complexity : O(n)
    Space Complexity : O(1)

4. String Compression
    Maintain a count variable initialized to 1 and traverse till the second last index of the array. Check the condition
    whether current character is equal to next character. If it is, simply increase the count, otherwise place the current
    character at kth index and then check if the count id greater than 1. If it is, convert count to string and place 
    every character at next index after k. In the end return the k value which will be the length of the modified array.

    C++: to_string(x) converts number to string
    JS: String(x) converts number to string

    Time Complexity : O(n)
    Space Complexity : O(1)

5. Are Permutation
    First check if the strings are of unequal length. If they are simply return false. Now create a frequency vector of
    256 indices and store the character frequency of the first string in the vector. Now subtract the character frequency
    of the second string from the same vector. Now traverse the array, if a non zero element is found the strings were not
    permutations, otherwise they were.

    To convert character to ascii in Javascript use Character.charCodeAt(0) method
    Example: 'a'.charCodeAt(0) will give 97.

    Time Complexity : O(n)
    Space Complexity : O(1)

6. Remove Duplicates
    First sort the string. Now create an output empty string. Traverse the string till the second last element and 
    everytime you find a character not equal to the next character, append that character to the output string. 
    After exiting the loop append the last character of the string to the output string and return the output string.
    
    Time Complexity : O(nlogn)
    Space Complexity : O(n)

7. Vowel Find
    Traverse the string, check if the current character is a vowel and append it to output. Otherwise skip the current 
    character.

    Time Complexity : O(n)
    Space Complexity : O(n)

8. Binary String to Number
    Traverse the string from right to left and maintain a power variable initialised to 0 and a sum and do simple binary 
    arithmetic. Keep increase power at every step and return the result in the end.

    Time Complexity : O(n)
    Space Complexity : O(1)

9. Find Substring Index
    Its a good idea to use the find function to find the index of the substring inside a bigger string.
    int index = s.find(sub);
    int nextIndex = s.find(sub, index+1);
    If at any point index is -1, it means the substring was not found.

    For Javascript use the indexOf() method i.e haystack.indexOf(needle, index+1); index+1 can be 0

    Time Complexity : O(n)

10. Find All Occurences
    Repeatedly run the find function, first with the substring as the argument then with substring and index+1 as the
    second argument until a -1 is returned which indicates that substring is not found.

    Time Complexity : O(n)

11. Space20
    Traverse the character array and find the number of spaces and length of the current string. The length of the new
    string would be length of current string + 2 * number of spaces. Now keep 2 pointers one at the end of the original
    string and one at the end of the calculated length of the new string. Transfer all characters from i to jth index, if
    a space is encountered insert a %20 (3 characters) at the jth index to j-2th index and decrease index of j by 3.

    Time Complexity : O(n)
    Space Complexity : O(1)

12. String Tokenizer
    We can tokenize string using stringstream. Pass the string as an argument inside stringstream and initialize a token string.
    stringstream ss(s);
    string token;

    while(getline(ss, token, ' ')) {
        cout<<token<<" ";
    }

13. String Key Sort
    First tokenise the string vector. Now sort the tokens using a comparator according to column number. Then reform
    the strings.

    Time Complexity : O(nlogn)
    Space Complexity : O(1)

14. Check Subsets
    Traverse both the strings from back. If the current characters match, decrease the index of smaller string otherwise
    keep traversing the larger string in backwards direction. If at the end, index of the smaller string becomes -1
    the smaller string is subset of the larger string.

    Time Complexity : O(n)
    Space Complexity : O(1)

15. Sort Subsequences
    First simply generate substrings of a string then sort them with a comparator.

    Time Complexity : O(2^n)
    Space Complexity : O(2^n)

    An important piece of information here is that a subset and a subsequence are same things 
    (they can have break in elements, they can be non continuous) but a substring must be continuous
    Eg: "abc" -> "ac" can be a subsequence but not a substring

16. Digital Clock
    Just check minute conversion, if its single digit append a 0 and return in hh:mm format.

    Time Complexity : O(1)
    Space Complexity : O(1)

17. Biggest Number String
    Sort the numbers using a special comparator
    to_string(num1) + to_string(num2) > to_string(num2) + to_string(num1)
    Then append all the numbers inside the sorted list and return the string.

    Time Complexity : O(nlogn)
    Space Complexity : O(1)

18. Palindrome Break
    If the word is only one character, return an empty string. Otherwise traverse till the middle of the string, find
    a character which is not 'a', convert it to 'a' and return the string. If not such character is found, convert the 
    last character to a 'b' and return the string.

    Time Complexity : O(n)
    Space Complexity : O(1)

19. String normalization
    Requires more closer analysis.



Basic Sorting Algorithms

1. Bubble Sort
    Run an outer loop for n-1 iterations and the inner loop starting from 0 to n-1-i iterations for each i. Swap two adjacent
    elements if they are out of order everytime.

    Time Complexity : O(n^2)
    Space Complexity : O(1)

2. Insertion Sort
    Start traversing the array from first index and store the value of the current element. Now start a backwards 
    iteration from current index - 1 comparing each element with the current element and moving the index-1th element
    to the index until an element is found which is lesser than the current value. Now swap the current element with 
    one index ahead of that element's position. Keep doing this till the array is sorted.

    Time Complexity : O(n^2)
    Space Complexity : O(1)

3. Selection Sort
    Start traversing the array with the outer for loop starting from 0th index and inner for loop one greater than outer
    index. Let's say the element at the 0th index is the minimum element. Now if the inner for loop finds an element which
    is smaller than the ith element, store that index. After the inner loop finishes, swap the stored index with the ith
    index. Repeat until sorted.

    Space Complexity : O(n)
    Time Complexity : O(1)

4. Counting Sort
    Create a frequency vector of each element of the input array where index of the element is the element. Now traverse 
    the frquency vector and insert each element in the correct position in the input array.

5. Pair Sticks
    Sort the array and traverse the array using 2 pointers. For each element check if their difference is less than or
    equal to D. If it is increase the count by 1 and erase both elements from the array. Repeat the process until less 
    than 2 elements remain or no more pairs can be formed.

    Time Complexity : O(n^2)
    Space Complexity : O(1)

6. Defense Kingdom
    Create 2 arrays to hold x and y coordinates. Insert 0 to both to signify the start of the board and then insert all
    x and y coordinates to both arrays. Now insert width+1 and height+1 of board to x and y vectors. Now sort both arrays 
    and calculate maximum difference of x and y coordinates. Return (maxW - 1) * (maxH - 1).

    Time Complexity : O(nlogn)
    Space Complexity : O(n)


Two Dimensional Arrays

1. Spiral Print

    Declare 4 variables sr, sc, er and ec. Now run a while loop which checks for sr <= er && sc<= ec and then traverse
    the boundary. Now decrease boundary at the end of one iteration of while loop. Keep doing so until the loop ends.

    Time Complexity : O(n * n)
    Space Complexity : O(1)

2. Wave Print

    Traverse the last column of the matrix from top to bottom and then decrease the row and maintain a boolean variable
    which dictates the direction of traversal. After every traversal flip the variable and repeat until all columns are
    exhausted.

    Time Complexity : O(n * n)
    Space Complexity : O(1)

3. Staircase Search

    Initialize a pointer to the first row and last column. If the target number is smaller go left, if its larger go
    down, repeat until element is found or the pointer reaches out of bounds.

    Time Complexity : O(n + m)
    Space Complexity : O(1)

4. Mango Trees

    First create a prefix sum 2D array where prefix(i,j) denotes the number of trees in that chunk of land. Now traverse the
    2D array and for each index i and j partition the land into 4 chunks with the number of trees in each chunk s1, s2, s3 and
    s4. Now find the minimum among all of them and update the max so far value. Retunr the max so far in the end.

    Time Complexity : O(n * n)
    Space Complexity : O(n * n)

5. Pascal's Triangle

    Create a nested loop and inside the inner loop check if either j is 0 or j is i, if they are push 1 to the current vector.
    Otherwise sum the values of op[i-1][j-1] and op[i-1][j] and push that sum to the vector. In the end of the inner iteration
    push the current vector in the output. Return the output in the end.

    Time Complexity : O(n * n)
    Space Complexity : O(n * n)

6. Submatrix Sum

    This one is similar to mango trees. First create the prefix sum 2D array and now let's create 4 sums which are s1, s2,
    s3 and s4. The important thing to note here is that s1 will be prefix[sr-1][sc-1] instead of prefix[sr][sc] as that will
    overlap with other sums. Also if any of sr and sc are 0 in the formation of s1, s2 or s3 these values will become 0 so
    add a check for that. In the end the result will be s4 - s2 - s3 + s1. 

    Time Complexity : O(n * n)
    Space Complexity : O(n * n)

7. Rotate Image

    In order to do this in-place the first step is to take the transpose of the array. Traverse the 2D array and for every
    i > j swap arr[i][j] and arr[j][i]. The second step is to do columnwise swapping. Again tarverse the array and swap every
    column with its mirror column if the mirror is placed in the center.

    Time Complexity : O(n * n)
    Space Complexity : O(1)


Sliding Window Problems

1. Housing
    The objective is to find out all the subarrays whose sum is equal to a target value. The elements will be positive.
    We create a window of size 0 with i and j initialised at index 0 and maintain a variable called cs = 0. Run a while
    loop with j < length of array and while cs is lesser than target keep expanding the window. Once cs exceeds target
    remove elements at the beginning. Now check if the cs is equal to the target and if it is, print the current window.

    Time Complexity: O(n)
    Space Complexity: O(1)

2. Maximum Substring with Unique Characters

    Create a hash map with charcter as a key and its index as a value. Traverse the string and at every index we will have
    two choices. Either the character does not exist inside the hash map or it does. The default step is to add it to the 
    hash table and increase the current window size by one and check the whether the current window size is greater than
    the max window size so far. If it is than set max_window_size to current window size and also set the start value to
    the i value. Before this check if the character exists inside the hash map and also the index inside the hash map is
    greater than i value (i.e the start of the current window). Now if it is set the i value to m[ch] + 1 and current length
    to j-i.

    Time Complexity O(n)
    Space Complexity O(n)

3. Minimum Window Substring

    The Objective is to find a minimum length substring inside the larger string which contains all the characters of the
    pattern string. To achieve this first create a frequency map FP for storing pattern string. Then create a map FS for
    storing the current window in question. Traverse the string, fill the FS map and maintain a variable called cnt. Now
    if the current character is present inside the pattern map and its frequncy inside the current window map is smaller
    or equal to the frequency inside the pattern map then increase cnt value by 1. 

    Now once the value of cnt is equal to the length of the pattern string, that means that all characters if the pattern
    exist inside the current window. So we will start removing characters from the beginning of the string or where our
    start pointer is placed. So if the character at start of the window does not exist inside the pattern map or its
    frequency inside the window map is greater than frequncy inside the pattern map, remove that element from the window
    map and increase the value of start. Keep repeating and check the current window size and compare with minimum size
    found so far. Also update the value of the window_start variable which is initialised with -1 which denotes the start
    index of the minimum window found so far.

    Time Complexity: O(n)
    Space Complexity: O(1)

4. Smallest Distinct Window
    This is exactly the same as maximum substring with unique characters.

5. Count subarrays with target sum
    This is a modification of the housing problem with negative numbers also existing inside the array. Create a prefix
    array and a hashmap which contains prefix sum as key and its frequency as value. Insert the first element of the array
    and set its value as 1. Traverse the array and fill the prefix index, then check if prefix[index]-k exists inside the
    map. If it does add its value to the count. Check another condition whether prefix[index] itself is equal to target.
    That means that starting from 0 index to current index sum of values is equal to target sum, add count+1 if this is true.
    Return the count at the end of the loop.


Binary Search

    1. Frequency Count
    
    First find the lower bound index of an element. To do that run the standard binary search routine
    but also maintain an extra variable called result initialised with -1. Whenever the target element is found, set the 
    result as that index and search in the left half. Keep doing this until convergence and lower bound will be acquired.
    Similarly find the uper bound but search in the right direction instead. Frequency count will be hi-lo+1.

    Time Complexity: O(logn)
    Space Complexity: O(1)

    2. Rotated Search

    Run a standard binary search routine but modify it as following. Check whether mid is the element, if it is then return
    mid as the answer otherwise there will be 2 cases. Either the mid lies on the first line or the second line.

    To check if the mid lies on the first line simply do arr[start] <= arr[mid] else the second line.
    If the mid lies on the first line, now check whether the target lies on the left hand side of the first line or right
    hand side. To check if the target lies on the left side simply check if arr[start] <= arr[target] and arr[target] <= arr[mid]
    and shift the end pointer to mid-1. Otherwise shift start to mid+1.

    If the mid lies on the second line check whether the target lies on the right hand side of the second line. Do this by
    checking if target >= arr[mid] && target <= arr[end]. If the target lies on the right side do start = mid + 1 otherwise
    end = mid - 1.

    Time Complexity : O(logn)
    Space Complexity : O(1)

    3. Square Root

    The objective is to find the square root of a number to a certain precision P. First run a simple binary search to find
    the first digit of the square root. Then inside a for loop which runs till P, run another loop which goes to a max value
    of 10 and keeps adding a factor to the result. If result times result becomes greater than result break the inner loop and
    subtract one factor value from the result.

    Time Complexity : O(logn + P)
    Space Complexity : O(1)

    4. Angry Birds

    Given N number of nests and B birds, we have to place these B birds on the nests such that no two birds are on the same
    nest and the separation between the birds is the maximum possible separation. This problem can be solved using binary search
    by modifying the search space. First sort the nests array and set lo as 0 and hi as the nest at the last index. Now run
    a binary search and check whether B birds can be placed on all the nests with a minimum separation of mid. If they can
    then set the result as mid and reduce the search space to mid + 1 and hi and if they cannot be placed then reduce the 
    search space in the left direction that is lo to mid-1 and do not update the result in this case. Keep updating and finding
    the maximum possible value of result and return it in the end.

    Time Complexity: O(nlogn + nlogm) where m is the maximum element inside the nests array 
    Space Complexity: O(1)

    5. Minimum Pairs

    Sort the second array and search for the lower bound of each value in the first array. The lower bound function will
    give the element in the second array which is just larger than the element in the first array. Now for every element 
    we will compare it with the element at the lower bound index and one previous element, calculate the difference and
    update some global variables. Make sure to handle some edge cases where lb-1 is greater than or equal to zero and the
    one where lb is lesser than size of array.

    Time Complexity: O(MlogM + NlogM) where N and M are the size of the first and second array respectively
    Space Complexity: O(1)

    6. Game of Greed

    The objective is to divide coins among k friends such that the first k-1 friends pick up the largest divisions and the 
    last friend remaining picks up the smallest division and that division is maximum possible. To do this create a search
    space of lo = 0 and hi  = sum of all coins. Now for every mid in binary search check if the distribution can be made, if
    it can then set lo to mid +1 and res to mid otherwise search in the left searchspace.

    Time Complexity: O(N * log(sum(N)))
    Space Complexity: O(1)

Basic Sorting Algorithms

    1. Bubble Sort

    Run the outer loop for n-1 times and the inner loop from 0 to n-1-times and keep swapping adjacent elements is the current
    element is larger than the next element. Every time the inner loop decreases by one since the elements keep going in their
    correct place after every inner loop iteration.

    Time Complexity : O(n * n)
    Space Complexity : O(1)

    2. Insertion Sort

    Run the outer loop from first index to last index and inside the loop traverse backwards and check if the element is larger
    than the current element, i.e the element marked by the outer loop. If it is keep replacing the next element with the
    element marked by inner iterator and once an element smaller than current is found replace the one next to it with the
    current element.

    Time Complexity : O(n * n)
    Space Complexity : O(1)

    3. Selection Sort

    For every element till the second last find the element in the res of the array which is smaller than it and save its index.
    Once the smallest index is found, replace it with the current element's index. Keep repeating until array is sorted.

    Time Complexity : O(n * n)
    Space Complexity : O(1)

    4. Counting Sort

    Find the largest element and create a new temporary array with its size. Now traverse the original array and at the index
    pointed by the element increase the count in the temp array. Now traverse the temp array and while an element is graeter
    than 0 keep adding that index to the original array while also incresing the index of the original array and decreasing the
    current element inside temporary array by 1.

    Time Complexity : O(largest + N)
    Space Complexity : O(largest)

    5. Pairing Sticks

    The objective is to find total pairs of sticks whose difference per pair is at most D. So sort the array and run two nested
    loops outer starting from 0 to n-2 and inner from outer+1 to n-1. Now check each pair's difference and if they satisfy the
    criteria increment the total by 1 and set both of them to INT_MAX as they cannot be used further. Do not consider INT_MAX
    values when finding the difference. 

    Time Complexity : O(n * n)
    Space Complexity : O(1)

    6. Defense Kingdom

    The objective is to find the largest area cpatured by the castles. So first collect the x and y coordinates from the 
    given pair array. Push 0 to the front of both and W+1 to the x array and H+1 to the y array. Now sort both the arrays. 
    Now find the largest difference of two consecutive elements in both the arrays. Subtact one from each and multiply them
    and that will be the result.

    Time Complexity : O(nlon + mlogm)
    Space Complexity : O(n + m)


Recursion, Backtracking and Divide and Conquer

    1. Factorial:

        Create a recursive function fact which takes in n as argument. If n is 0 return 1 which is the base case otheriwse 
        in general case return n * fact(n-1).

        Time Complexity : O(n)
        Space Complexity : O(n) When stack memory is the largest which is the depth of the tree.

    2. Fibonacci:

        Create a recursive function. And for every n the result will be its previous two terms. So fib(n) will be fib(n-1)
        + fib(n-2). If n is 0 or 1 return n.

        Time Complexity : O(2 ^ n)
        Space Complexity : O(n) Max depth of the recursive tree.

    3. Sorted array check:

        Create a recursive function that takes in an array and n which are number of elements inside the array. Now for the
        base case if n is 0 or n is 1 i.e. no or only one element is in the array return true. Otherwise check if arr[0] < arr[1]
        and the rest of the array is also sorted. To check for the rest of the array pass in arr + 1 and n-1 to the function and
        if both of them are true, return true otherwise return false.

        Time Complexity : O(n)
        Space Complexity : O(n)

    4. Print Increasing Decreasing

        For the decreasing function first print the number than call the function on the reduced input and return when the 
        input reaches 0. For the increasing function, first call the function on the reduced input then print the number.

        Time Complexity : O(n)
        Space Complexity : O(n)

    5. First Occurence

        Recursively traverse the array while increase array address by 1 and decreasing n by 1 and check if arr[0] is equal
        to the target. If it is return 0. Now make a call to the rest if the array and store it inside subIndex. Id subIndex
        is not -1 that means the rest of the array contains the target so return subIndex + 1 otherwise return -1. For the 
        base case if no more elements are present in the array i.e. n is 0 return -1.

        Time Complexity : O(n)
        Space Complexity : O(n)

    6. Last Occurence

        Recursively traverse the array and store the result inside subIndex, when the size is 0 return -1. Now check if
        subIndex is -1, if it is check if the element at index 0 is the target and if it is return 0 otherwise return -1.
        Id subIndex is not -1 that means we have the last position of the target so return subIndex+1.

        Time Complexity : O(n)
        Space Complexity : O(n)

    7. Power Function

        Create a function which takes in two arguments a and n and the goal is to compute a ^ n. The recursion can be written
        as f(n) = (a ^ (n/2)) * (a ^ (n/2)) is n is even and a * (a ^ (n/2)) * (a ^ (n/2)) if n is odd. So first compute the
        half power recursively and then half_power_square by multiplying half_power it by itself. Return a * hps or hps depeneding 
        upon whether n is odd or even.

        Time Complexity : O(logn)
        Space Complexity : O(logn)

    8. Tiling Problem

        The problem is to find the number of ways to cover a N X M board with M X 1 tiles. In the recursive case there are
        two ways to cover the board, either place N tiles horizontally which will decrease the length of the board by M
        or lay one tile vertically which will decrease the length of the board by 1. In the base case if the length of the
        board becomes lesser than M then there will be only 1 way to lay out tiles on the board. So in the rescursive case
        f(N) = f(N-M) + f(N-1). 

        Time Complexity : O(2 ^ n)
        Space Complexity : O(n)

    9. Binary Strings

        Generate n digit strings such that there are no consecutive ones. While generating the string if we place 0 then
        the rest of the digits can be anything but if we place 1 then the next digit must be 0 so that no consecutive 1's
        appear. So the recursive case becomes f(N) = f(N-1) + f(N-2) and as for the base case, if N is 0, then return 1 since
        and if N is 2 return 2.

        Time Complexity : O(2 ^ n)
        Space Complexity : O(n)

    10. Friends Pairing

        Find the number of ways N friends can be paired if a friend can either decide to go alone or pair with any other person
        in the group. So the recursive case becomes f(N) = 1 * f(N-1) + (N-1) * f(N-2) since if the friend decides to go alone
        then rest of people can go in f(N-1) ways and if person decides to pair up, he can pair with any of N-1 friends and the
        rest can go in f(N-2) ways. As for the base case if N is 0 return 1 and if N is 1 then also return 1.

        Time Complexity : O(2 ^ n)
        Space Complexity : O(n)

    11. Merge Sort

        Merge sort is a recursive algorithm and has three steps. First find the mid index of the array then call the merge sort
        from start to mid and another merge sort call from mid+1 to end. Now merge the array. For the base case if only one or 0
        elements remain in the array, return. For the merge function again find the mid point and create a temporary vector and merge
        the two divisions of the original array in the temp array and then copy the contents of the temp array back to the original
        array from start to end.

        Time Complexity : O(nlogn)
        Space Complexity : O(n)

    12. Quick Sort

        Quick sort is another recursive algorithm. In the main function first we find the pivot index using another function called partiton,
        now we recursively call quick sort from start to pivot - 1 and another call from pivot + 1 to end. In the partition function we set the
        last elemennt of the section of array to the pivot, now we arrange the rest of the array around that pivot such that elements lesser
        than the pivot are on the left side and greater than pivot are on the right side. Then we put the pivot in its correct position and return
        the index of the pivot. To accomplish this with code we create two pointers i initialised to start-1 and j initialised to s. Now while 
        traversing the array using j if an element lesser than pivot is encountered we replace arr[i+1] with that element and increase the value of
        i by 1. Keep doing so and once out of the loop replace arr[end] which is the pivot with arr[i+1] which is the boundary index and then return
        i+1.

        Average Time Complexity : O(nlogn)
        Space Complexity : O(n)

    Backtracking is used to solve three kinds of problems

        I. Decision problems: In this kind of problem we have to find a feasible solution given some constraints, e.g find if the rat can go from some starting
            point to a destination point. 

        II. optimisation problem: Find the best possible solution. e.g. travelling salesman problem

        III. Enumeration Problem: Find all possible solutions. e.g. Find all substrings or all permutations of a string.

    13. Finding Subsets

        Create a recursive function which takes in two strings as parameters, one the original string and other an empty
        string which is the answer. Extract the first character and create the substring of the string starting from 1st
        character. Make to calls to the recursive function, include the character in one of the answers of the two calls
        which traslates to including and excluding the current character. Once the original string is empty, print out the
        answer string which corresponds to one possible substring or subset.

        Time Complexity : O(2 ^ n)
        Space Complexity : O(n)

    14. Permutations

        Create a recursive function which takes in a string and an index starting from i = 0. For the recusrive case run a 
        for loop from j=i to j lesser than string length. Swap the i and j characters and find the permutations for the rest
        of the string. Once i is on the last index and only one character remains print the string and return. Now after 
        the function returns to the original recursive call swap i and j again to reset the string.

        Time Complexity : O(2 ^ n)
        Space Complexity : O(n)

    15. N Queen Problem

        The problem comes in 2 flavors, one in which we have to find one possible solution and another in which we have to
        find all possible solutions. Traverse the current row and check if the queen can be placed at the current index using
        is_safe function which involved checking if a queen is already placed in some diagonal or current column. If it is safe
        place the queen and call the function for the next row. If the program is successfull in finding a solution, return true
        otherwise remove the queen from the current cell. If no position on the current row is possible return false from the
        current recursive call. In the base case if i reaches n return true as a solution was successfully discovered. In the case
        of count all ways, the function return type should be int and return 1 from the base case instead of true. For recursive
        calls create a variable called ways = 0 and add the result of every recusrive call to ways and then return ways from
        the solution.

        Time Complexity : O(n^n) or tighter bound is O(n!)
        Space Complexity : O(n)

    16. Grid ways

        Give an NXM grid and you at index 0,0 and you can move either right or down, find the number of ways to go from start
        of the grid to the end of the grid. Create a function with i and j initialised to 0 and n and m and if i and j reach
        n-1 and m-1 return 1 as it denotes one possible solution. If i exceeds n-1 or j exceeds m-1 return 0. For the recursive
        case add f(i+1) and f(j+1).

        Time Complexity : O(2 ^ (n+m))
        Space Complexity : O(n + m)

    17. Sudoku Solver

        Give a n * n grid with partially filled numbers, solve the sudoku. Traverse the sudoku board using the recusrive functions
        which take in row and col, if current cell is occupied move the the next by increasing col in recursive call. Once an
        unfilled cell is encountered try filling all possible values from 1 to n using is_safe function which checks whether
        the entire column, the entire row and the entire (n/3)X(n/3) submatrix does not contain the current number in question.
        If it is safe put the number and check for the rest of the sudoku board. If a solution is possible return true. Otherwise
        try placing the next number. If no solution is possible, reset the current cell and return false. For the base case if
        i which represents row reaches n that means entire board was solved so return true. If j reaches n, go to the next row
        with column as 0 using the same function.

        Time Complexity : O(n ^ n*n)
        Space Complexity : O(n*n)

    19. Rat and Mice

        Variation of rat in a maze where you have to return the visited array. So simply use a dfs routine along with a visited
        array and and once the last cell is reached return true. Mark the current cell as visietd and for each cell try to move 
        to its adjacent cells i.e if adjacent cells are unblocked and not visited. If one of those cells give a possible 
        solution return true. Otherwise mark the cell as unvisited return false once outside the loop.

        Time Complexity : O(n + m)
        Space Complexity : O(n + m)

    20. Word break problem

        Find the number of ways the string can be partitioned such that all the words exist inside the dictionary. First add
        all words of dictionary to an unordered set for faster access. Create a recursive function with two pointers i and j
        with i marking the start of the substring and j marking the end of the substring. Check if the current substring
        exists inside the set and if it does we can either include the current string or exclude it so sum up both the cases
        in a gloabal variable called ways. If the word does not exist simply move the j pointer ahead which is the case where
        we do not include the current word. In the base cases if j reaches the end of the string and i is equal to j return 1.
        If j reaches the end of the string and i does not, return 0. 

    21. Word Search Problem

        Traverse the entire array and check if the current character is the first character if the word. If it is, run a dfs
        routine starting from that cell and try to find the entire word. Make use of visited array to make sure no cell is 
        visited twice. Once the last character of the word is found return true. In the main function if the dfs returns a true
        then return a true, otherwise search the rest of the board. Once out of the double for loop return false.

    22. Climbing Ladders

        Starting from 0 index you can take either 1, 2 or 3 steps forward. Find the number of ways to reach the last step.
        So f(n) can be defined as f(n) = f(n-1) + f(n-2) + f(n-3). As for the base cases if n is 0 return 1 and if n is < 0
        return 0 as that is an invalid case.

        Time Complexity : O(2 ^ 3)
        Space Complexity :O(n)

    23. Count Subset sum to X

        Create a recursive function which takes in an array and the index. Include and exclude the current element in the
        recursive calls by subtracting from target sum. Once you reach the end of array check if target is 0. If it is that
        means one subset was found which sums up to X. So return 1. Add the results of both recursive calls.

        Time Complexity : O(2 ^ n)
        Space Complexity : O(n)

    24. Generate Brackets

        The objective is to generate balanced brackets. Create a recusrive function with n, open count and close count and
        a string as the parameters. If open count is smaller than n, add an opening bracket to the string. If close count
        is smaller than open count add a close bracket to the string. For the base case if string length is 2 * n print the
        string and return. This method of controlling the branches is called branch pruning (Loki rings a bell).

        Time Complexity : O(2 ^ n)
        space Complexity : O(n)

    25. Smart Keypad

        First create a vector of strings representing the keypad with its corresponding strings. Now create a recusrsive
        function and parse each character in the string converting it to its corresponding index. Now for every character
        in the keypad mapped to that index, add that character to a string argument and call the rescursive function again
        for the next index of the string. Once the string runs out print the string which is formed. 

        Time Complexity : O(3 ^ n)
        Space Complexity : O(n)

    26. Game of Coins:

        The objective is as follows, 2 players are playing the game of picking up coins. Both players can pick the coin
        from extreme ends of the array. Find the max value that the first player picks up in order to win the game. Both
        players play optmally. 
        The recursive definition will work as follows:
        If player pickes up the coin from left then pick_left = coins[l] + min(f(l+2, r), f(l, r-1)) and similarly
        pick_right = coins[r] + min(f(l+1, r), f(l, r-2)). Then return max(pick_left, pick_right). We have to use
        min function because we assume that when the second player plays his move, we will get the worst possible
        result when the first player plays the third move. But we have to return max(pick_left, pick_right) as that is
        something that first player can control.

    
    



Dynamic Programming

    Optimal Substructure: Optimal Substructure means a problem can be solved by breaking it into subproblems and combining
    the solutions of the subproblems.

    Overlapping Subproblems: Subproblems which are being computed again and again.

    1. NK Ladders 
        Problem is that starting from 0 and taking anuywhere from 1 to k steps at a time, how many ways are there to reach the
        Nth step.

        Recursive Solution: Start from N and run a loop from 1 to K. Call the function inside every iteration of the loop.
        subtracting the i value from N. Maintain an ans varable initialised at the top to 0 and add the result of every 
        recursive call to the ans. The return the ans outside the loop. Base case will be if 0 is reached then return 1 as
        that is a valid way, if < 0 then return 0. This is like an enhanced version of fibonacci but the base case is
        slightly different.

        Time Complexity : O(2 ^ n)
        Space Complexity: O(2 ^ n)

        Bottom Up: Create a dp array of size N+1, initialize 0 index with 1 and add previous k values to the current cell.

        Time Complexity : O(N * k)
        Space Complexity : O(N)

        Bottom Up Optimised : Create an array of N+1 length and initialize 0 index with 1. For every cell i the result
        will be 2 * dp[i-1] - d[i-k-1]. For the first k cells the answer for each cell i would be simply 2 * dp[i-1].

        So first run a loop for 0 to k and then k+1 to N.

        Time Complexity : O(N)

    2. Coin Change (Coin Change I)

        The objective is to find the minimum number of coins required to create a given amount. The recursive definition
        can be written as for all coins in denominations subtract the current coin from the amount and calculate the min
        coins required for creating the amount currentAmount - coins[i], and do the same for all coins and find out the
        minimum result among all of them and add one to it. If the amount is 0 which is the base case then return 0 since
        0 coins are required to make 0 amount. Also make sure that call is not being made to an amount lesser than 0.

        Time Complexity O(C^N) where C are coins and N is amount

        In the Bottom Up Approach, create an array of size amount+1. First set the current index to INT_MAX and then for every
        index starting 1 check all the coins required to make that amount(index). If index - coin  >= 0 only consider the 
        coin and check the value of dp array at that index, if its not INT_MAX then  add one to that amount and take a minimum
        with current value of dp[i]. Do so for all of the coins and in the end check the value of last index, if its INT_MAX
        return -1 as creating that value would be impossible otherwise return the value.

        Time Complexity O(N * C) where C are total coins and N is the amount.


    3. Rod Cutting:

        Find the maximum profit that can be obtained by cutting a rod of length N into multiple pieces. Price of each piece is
        given. The recursive solution is to run a loop from 0 to N and make a cut of length i+1 on the rod. Add the price of the
        current cut and recursively calculate the price of the remaining rod. If rod length becomes 0 return 0 as the base case.
        Now for all the cuts check the max profit obtained for all the cut prices and their respective subproblems.

        For the bottom up solution first create a dp array of length N+1 and initialize dp[0] to 0. Now run a loop for length 1
        to N and run an inner loop for j equals 0 to j lesser than len. Now the cut would be of length j+1. So Add the price
        of j and dp[len-cut] and keep doing so for all the cuts while maintaining a max value and at the end of the inner loop
        set the current dp[len] to that value. Return dp[N] at the end of the function.

        Time Complexity: O(N^2)
        Space Complexity: O(N)

    4. Minimum Jumps:

        Given an array whose indices denote maximum jump you can take at that index. Return the minimum jumps needed to reach the 
        last index. Recursively this problem can be broken down as follows, starting from jump = 1 to jump = arr[idx] add 1 + 
        function call at the jump + idx index and find the 1 + minimum of all those recursive calls. In the base case if the last
        index is reached return 0, and if array boundary is exceeded return INT_MAX. While checking for subproblems check if
        a subproblem returns an INT_MAX and if it does do not consider it while calculating the min jumps. 

        For the bottom up approach traverse the array from n-2th index to 0. For each index calculate what will be the minimum
        amount of jumps to get from there till end by running an inner loop which checks from jump = 1 to jump = arr[i].
        Take the minimum of all possible results.

    5. Longest Common Subsequence: 
        Important: Initialize 2D DP array with -1 since 0 could be a valid answer during TD code.

        Objective is to find the maximum length of the common subsequence between two strings. In recursive or top down approach
        initialize both the strings from i=0 and j=0 and check if the charcter at both the strings match. If it does then add 1
        to the recursive call on the remaining both strings from i+1 and j+1. If they do not match at the current indices then
        find the max of i+1 of the first string and j+1 of the second string and return it. In the base case if i or j reach end
        of their respective strings then simply return 0. Please note during memoisation of TD Solution, Initialise the array with
        -1 values as 0 can also be a valid answer.

        In the Bottom Up Approach create an array of s1.size()+1 and s2.size()+1 dimensions and the first row and column should
        be initialised with 0 as i=0 and j=0 denote empty strings and act as base cases. Now traverse the 2d array from 1 based 
        indexing and if the current charcter matches add 1 to the result stored in the left upper diagonal(i-1, j-1) and if they
        do not match then store the maximum of the cells directly above and to the left max(dp(i-1, j) and dp(i, j-1)).
        The final answer will be stored at the last index. 

        If we want to generate the string we must start tracing the array from the last index. If the value of the current index
        matches with the one directly above then move the pointer to directly above and if the value matches to the index directly
        on the left, move the pointer to left and if they don't then the current indices should match, add the character to the
        output and move to i-1 and j-1.


Queues
    1. First Non Repeating Letter
        We are given an input stream of characters and we have to tell the first non repeating character for every single 
        index inside the input stream. The algorithm to do so is as follows:

        Create a hash map (frequency map) and a queue Traverse over the string and add the character to the map and push it 
        to the queue. Now check every single character starting from the front of the queue and if its frquency is greater
        than 1 inside the map, remove that character. Do so until the queue is empty or the first character inside the queue
        has frequency equal to 1. If the queue is empty print a -1 otherwise print the first character of the queue.

Heaps
    For the running median, 3 overall cases (comparing heap sizes) and 2 cases for each of them.



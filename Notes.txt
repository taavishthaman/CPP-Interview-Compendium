Arrays and Vectors

1. Linear Search
    Simply run a for loop on an array, if the current element matches the target return that index. If the loop ends
    return -1 indicating that the element was not found.'
    Time Complexity : O(n)
    Space Complexity : O(1)

2. Binary Search
    Keep 2 pointers lo and hi with lo at 0 and hi at the last index of the array. Now find a mid point using (lo+hi)/2.
    Check if the target element is equal to the element at the mid index. If so, return the mid index. If not, check 
    whether the target element is smaller than the mid element or larger. If smaller, search in the left search space by
    reducing the search space by doing hi = mid - 1. If larger, search in the right search space by reducing the search
    space by doing lo = mid + 1. Repeat the algorithm until search space reduces to 0. If the element is not found return ]
    -1.
    Time Complexity : O(n)
    Space Complexity : O(1)

3. Array Reverse
    Swap every element from the start to the mid of the array with its corresponding element beginning from the end.
    0 with last element, 1 with second last element and so on till the middle of the array.
    Time Complexity : O(n)
    Space Complexity : O(1)

4. Print Subarrays
    Keep two pointers i and j which traverse the array inside a double for loop. Now print all the elements between i
    and j essentailly printing all the subarrays.
    Time Complexity : O(n^3)
    Space Complexity : O(1)

5. Print Pairs
    Use 2 for loops starting from i = 0 and j = i+1. Print all elements at i and j which will essentially print all pairs.
    Time Complexity : O(n^2)

6. Largest Element
    Set largest_so_far to the first element of the array. Now traverse the array from 1 to n-1 and update largest_so_far
    to the current element if current element is larger than largest_so_far. Return largest_so_far after the loop ends.
    Time Complexity : O(n)
    Space Complexity : O(1)

7. Maximum Subarray Sum
    Create a new array dp and set dp[0] to arr[0]. Now run a for loop where dp[i] = max(nums[i], dp[i-1]+nums[i]). Find the
    largest element in the dp array which will be maximum subarray sum.
    Time Complexity : O(n)
    Space Complexity : O(n)

8. Lower Bound
    This involves the use of binary search. Check the mid of the array. If the arr[mid] is <= target, that could be the lower
    bound so update the ans to arr[mid] and search in the right part of the array. If arr[mid] > target search in the
    left part of the array.
    Time Complexity : O(logn)
    Space Complexity : O(1)

9. Sorted Pair Sum
    Keep two pointers i and j at the start and end of the array. Check the abs difference of the sum of these elements
    from the target element. Keep a minimum absolute difference variable and check whether the current abs diff is smaller.
    If it is save the current pair. Now if current pair sum is smaller than target increase i value otherwise decrease
    j value and repeat the process.
    Time Complexity : O(n)
    Space Complexity : O(1)

10. K Rotate
    The optimized way of doing this is, first reverse the entire array. Then reverse the first k elements and then the 
    last (n-k) elements.
    [1,2,3,4,5] and k = 2
    [5,4,3,2,1] (step 1)
    [4,5,3,2,1] (step 2)
    [4,5,1,2,3] (step 3)
    Time Complexity : O(n)
    Space Complexity : O(n)

11. Inbuilt Search
    Use the find method to do a linear search inside array. 
    auto it = find(v.begin(), v.end(), target);
    int index = it - v.begin()

12. Rotate Image
    This problem can be broken down into 2 steps
    First take the transpose of the matrix

    for(int i=0; i<n; i++) {
        for(int j=0; j<n; j++) {
            if(i > j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }

    Then do a columnwise swapping

    for(int i=0; i<n/2; i++) {
        for(int j=0; j<n; j++) {
            swap(matrix[j][i], matrix[j][n-1-i]);
        }
    }

    Time Complexity : O(n^2)
    Space Complexity : O(1)

13. Set matrix zeroes
    First traverse the matrix and store all the pairs of row and cols which are zeroes.
    Now traverse the stored pairs and set each row and col to 0.
    (This however is not the most optimal solution)

    Time Complexity : O((n+m) * (n+m)) (In worst case)
    Space Complexity : O(n*m)

14. Two Sum
    Traverse the array and keep a hash map to keep track of all the visited elements inside the array. If you find an element
    such that another element exists inside the hash map and their sum is equal to target, return their indices.

    Time Complexity : O(n)
    Space Complexity : O(n)

15. Three Sum
    First sort the array, then traverse the array till the third last element and create 2 more pointers start and end
    which check the array for triplets for every outer for loop iteration. For some further optimisation add condition
    if(nums[i] == nums[i-1]) {continue} to avoid unnecessary duplicacy in computation.

    Time Complexity : O(n^2)
    Space Complexity : O(n)

16. Largest Mountain
    Traverse the array from 2nd to 2nd last element and find a peak element. Peak element is the element which is greater
    than both its neighbors. Then start running a while loop in left and right directions from that element keeping track 
    of count at every iteration. The count at the end is the length of the mountain, check if the current mountain length
    is greater than the one found so far.

    Time Complexity : O(n)
    Space Complexity : O(1)

17. Longest Consecutive Sequence
    Insert each element inside an unordered set. Now traverse the array and check if the current element starts a chain.
    Current element will start a chain if one lesser than that element does not ecist inside the set. Now once you have
    the beginning of the chain, keep checking for the next element inside the set and keep increasing the count by one.
    The count after the end of the loop is the length of the current chain you found. Update the global chain length with
    that length.

    Time Complexity : O(n)
    Space Complexity : O(n)

18. Rainwater Trapping
    First calculate the maximum till now left heights and store the values inside an array. Similarly calculate maximum
    till now right heights and store them inside an array. Now for each element do min(left, right) - curr_height to get
    the amount of water stored inside the current index. Add them all up and you will have the total water.

    Time Complexity : O(n)
    Space Complexity : O(n)

19. Subarray Sort
    First find the smallest and largest element which are out of order inside the array. Now traverse the array from
    left to right and find the index of element which is greater than the smallest element we found. Similarly traverse
    the array from right to left and find the index of element which is smaller than the largest element we found. These 
    2 indices denote the size of unsorted array that needs to be sorted in order for entire array to be sorted.

    Time Complexity : O(n)
    Space Complexity : O(n)

20. Minimum Swaps
    First create a copy of the array along with its indices in a new pair vector. Now sort this new vector. Now traverse 
    the array and maintain a visited array. If the element is already visited or is in its correct position skip that element.
    Otherwise start a cycle from that index and keep going to the index marked by the second element inside the pair vector
    and keep marking all indices as visited. Keep doing this until you reach the element which is visited. Add steps - 1
    to the total swaps variable you did for this entire routine. Return the total swaps at the end of the program.

    Time Complexity : O(logn) (Because of sorting)
    Space Complexity : O(n)

21. Minimum Difference
    First sort both the arrays. Now keep 2 pointers, one at the beginning of each array. Now keep calculating minimum difference.
    If the element in the first array is smaller increase the index of first array, if index in second array is smaller
    increase the index of second array. Keep calculating minimum difference at every step. Write a routine like the merge function.

    Time Complexity : O(n + m)
    Space Complexity : O(n)

22. Product of Array Except Self
    Create an array and calculate the prefix products for each element. Now keep a product variable initialized to 1 and
    start traversing the array in backwards direction and for every element in the new array mark current index as product
    of product variable and one perevious element in prefix array. Now mark product as product times current element inside
    the original array.

    Time Complexity : O(n)
    Space Complexity : O(n)

23. Min Arrows to burst Balloons (Busy Life)
    First sort the pair array according to the second coordinate in each points. Now save the first interval's end and traverse
    the array from the first index. Now if current start element is smaller than or equal to the previous ending element
    do nothing because all those balloon are overlapping and can be burst with one arrow only, otherwise increase the number 
    of arrows required by one. Return the total arrows required at the end of program.

    Time Complexity : O(n)
    Space Complexity : O(1)


Strings

1. Count Digits and Spaces
    Simply traverse the string and maintain two counts which are count_spaces and count_digits both initialised to 0.
    Whenever a space is encountered i.e current character == ' ' increase the count of spaces by one and whenever a 
    digit is encountered i.e cc >= '0' and cc <= '9' increase the count of digits by one.
    
    Time Complexity : O(n)
    Space Complexity : O(1)

2. Find Shortest Path
    First calculate the total displacement in x and y direction. Now create an output empty string and if final x is less
    than 0 that means the movement was in east and if x was greater than 0 movement was in west. Similarly if final y 
    is less than 0 that means movement was in south and otherwise movement was in north.

    Time Complexity : O(n)
    Space Complexity : O(1)

3. Is Palindrome
    Traverse the array from start to middle, compare the ith element with (n-1-i)th element, if they are not equal return
    false. If the loop is terminated return true.

    Time Complexity : O(n)
    Space Complexity : O(1)

4. String Compression
    Maintain a count variable initialized to 1 and traverse till the second last index of the array. Check the condition
    whether current character is equal to next character. If it is, simply increase the count, otherwise place the current
    character at kth index and then check if the count id greater than 1. If it is, convert count to string and place 
    every character at next index after k. In the end return the k value which will be the length of the modified array.

    Time Complexity : O(n)
    Space Complexity : O(1)

5. Are Permutation
    First check if the strings are of unequal length. If they are simply return false. Now create a frequency vector of
    256 indices and store the character frequency of the first string in the vector. Now subtract the character frequency
    of the second string from the same vector. Now traverse the array, if a non zero element is found the strings were not
    permutations, otherwise they were.

    Time Complexity : O(n)
    Space Complexity : O(1)

6. Remove Duplicates
    First sort the string. Now create an output empty string. Traverse the string till the second last element and 
    everytime you find a character not equal to the next character, append that character to the output string. 
    After exiting the loop append the last character of the string to the output string and return the output string.
    
    Time Complexity : O(logn)
    Space Complexity : O(n)

7. Vowel Find
    Traverse the string, check if the current character is a vowel and append it to output. Otherwise skip the current 
    character.

    Time Complexity : O(n)
    Space Complexity : O(n)

8. Binary String to Number
    Traverse the string from right to left and maintain a power variable initialised to 0 and a sum and do simple binary 
    arithmetic. Keep increase power at every step and return the result in the end.

    Time Complexity : O(n)
    Space Complexity : O(1)

9. Find Substring Index
    Its a good idea to use the find function to find the index of the substring inside a bigger string.
    int index = s.find(sub);
    int nextIndex = s.find(sub, index+1);
    If at any point index is -1, it means the substring was not found.

    Time Complexity : O(n)

10. Find All Occurences
    Repeatedly run the find function, first with the substring as the argument then with substring and index+1 as the
    second argument until a -1 is returned which indicates that substring is not found.

    Time Complexity : O(n)

11. Space20
    Traverse the character array and find the number of spaces and length of the current string. The length of the new
    string would be length of current string + 2 * number of spaces. Now keep 2 pointers one at the end of the original
    string and one at the end of the calculated length of the new string. Transfer all characters from i to jth index, if
    a space is encountered insert a %20 (3 characters) at the jth index to j-2th index and decrease index of j by 3.

    Time Complexity : O(n)
    Space Complexity : O(1)

12. String Tokenizer
    We can tokenize string using stringstream. Pass the string as an argument inside stringstream and initialize a token string.
    stringstream ss(s);
    string token;

    while(getline(ss, token, ' ')) {
        cout<<token<<" ";
    }

13. String Key Sort
    First tokenise the string vector. Now sort the tokens using a comparator according to column number. Then reform
    the strings.

    Time Complexity : O(nlogn)
    Space Complexity : O(1)

14. Check Subsets
    Traverse both the strings from back. If the current characters match, decrease the index of smaller string otherwise
    keep traversing the larger string in backwards direction. If at the end, index of the smaller string becomes -1
    the smaller string is subset of the larger string.

    Time Complexity : O(n)
    Space Complexity : O(1)

15. Sort Subsequences
    First simply generate substrings of a string then sort them with a comparator.

    Time Complexity : O(2^n)
    Space Complexity : O(2^n)

16. Digital Clock
    Just check minute conversion, if its single digit append a 0 and return in hh:mm format.

    Time Complexity : O(1)
    Space Complexity : O(1)

17. Biggest Number String
    Sort the numbers using a special comparator
    to_string(num1) + to_string(num2) > to_string(num2) + to_string(num1)
    Then append all the numbers inside the sorted list and return the string.

    Time Complexity : O(nlogn)
    Space Complexity : O(1)

18. Palindrome Break
    If the word is only one character, return an empty string. Otherwise traverse till the middle of the string, find
    a character which is not 'a', convert it to 'a' and return the string. If not such character is found, convert the 
    last character to a 'b' and return the string.

    Time Complexity : O(n)
    Space Complexity : O(1)

19. String normalization
    Requires more closer analysis.



Basic Sorting Algorithms

1. Bubble Sort
    Run an outer loop for n-1 iterations and the inner loop starting from 0 to n-1-i iterations for each i. Swap two adjacent
    elements if they are out of order everytime.

    Time Complexity : O(n^2)
    Space Complexity : O(1)

2. Insertion Sort
    Start traversing the array from first index and store the value of the current element. Now start a backwards 
    iteration from current index - 1 comparing each element with the current element and moving the index-1th element
    to the index until an element is found which is lesser than the current value. Now swap the current element with 
    one index ahead of that element's position. Keep doing this till the array is sorted.

    Time Complexity : O(n^2)
    Space Complexity : O(1)

3. Selection Sort
    Start traversing the array with the outer for loop starting from 0th index and inner for loop one greater than outer
    index. Let's say the element at the 0th index is the minimum element. Now if the inner for loop finds an element which
    is smaller than the ith element, store that index. After the inner loop finishes, swap the stored index with the ith
    index. Repeat until sorted.

    Space Complexity : O(n)
    Time Complexity : O(1)

4. Counting Sort
    Create a frequency vector of each element of the input array where index of the element is the element. Now traverse 
    the frquency vector and insert each element in the correct position in the input array.

5. Pair Sticks
    Sort the array and traverse the array using 2 pointers. For each element check if their difference is less than or
    equal to D. If it is increase the count by 1 and erase both elements from the array. Repeat the process until less 
    than 2 elements remain or no more pairs can be formed.

    Time Complexity : O(n^2)
    Space Complexity : O(1)

6. Defense Kingdom
    Create 2 arrays to hold x and y coordinates. Insert 0 to both to signify the start of the board and then insert all
    x and y coordinates to both arrays. Now insert width and height of board to x and y vectors. Now sort both arrays and 
    calculate maximum difference of x and y coordinates. Return (width - 1) * (height - 1).


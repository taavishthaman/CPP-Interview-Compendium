Arrays and Vectors

1. Linear Search
    Simply run a for loop on an array, if the current element matches the target return that index. If the loop ends
    return -1 indicating that the element was not found.'
    Time Complexity : O(n)
    Space Complexity : O(1)

2. Binary Search
    Keep 2 pointers lo and hi with lo at 0 and hi at the last index of the array. Now find a mid point using (lo+hi)/2.
    Check if the target element is equal to the element at the mid index. If so, return the mid index. If not, check 
    whether the target element is smaller than the mid element or larger. If smaller, search in the left search space by
    reducing the search space by doing hi = mid - 1. If larger, search in the right search space by reducing the search
    space by doing lo = mid + 1. Repeat the algorithm until search space reduces to 0. If the element is not found return ]
    -1.
    Time Complexity : O(n)
    Space Complexity : O(1)

3. Array Reverse
    Swap every element from the start to the mid of the array with its corresponding element beginning from the end.
    0 with last element, 1 with second last element and so on till the middle of the array.
    Time Complexity : O(n)
    Space Complexity : O(1)

4. Print Subarrays
    Keep two pointers i and j which traverse the array inside a double for loop. Now print all the elements between i
    and j essentailly printing all the subarrays.
    Time Complexity : O(n^3)
    Space Complexity : O(1)

5. Print Pairs
    Use 2 for loops starting from i = 0 and j = i+1. Print all elements at i and j which will essentially print all pairs.
    Time Complexity : O(n^2)

6. Largest Element
    Set largest_so_far to the first element of the array. Now traverse the array from 1 to n-1 and update largest_so_far
    to the current element if current element is larger than largest_so_far. Return largest_so_far after the loop ends.
    Time Complexity : O(n)
    Space Complexity : O(1)

7. Maximum Subarray Sum
    Create a new array dp and set dp[0] to arr[0]. Now run a for loop where dp[i] = max(nums[i], dp[i-1]+nums[i]). Find the
    largest element in the dp array which will be maximum subarray sum.
    Time Complexity : O(n)
    Space Complexity : O(n)

8. Lower Bound
    This involves the use of binary search. Check the mid of the array. If the arr[mid] is <= target, that could be the lower
    bound so update the ans to arr[mid] and search in the right part of the array. If arr[mid] > target search in the
    left part of the array.
    Time Complexity : O(logn)
    Space Complexity : O(1)

9. Sorted Pair Sum
    Keep two pointers i and j at the start and end of the array. Check the abs difference of the sum of these elements
    from the target element. Keep a minimum absolute difference variable and check whether the current abs diff is smaller.
    If it is save the current pair. Now if current pair sum is smaller than target increase i value otherwise decrease
    j value and repeat the process.
    Time Complexity : O(n)
    Space Complexity : O(1)

10. K Rotate
    The optimized way of doing this is, first reverse the entire array. Then reverse the first k elements and then the 
    last (n-k) elements.
    [1,2,3,4,5] and k = 2
    [5,4,3,2,1] (step 1)
    [4,5,3,2,1] (step 2)
    [4,5,1,2,3] (step 3)
    Time Complexity : O(n)
    Space Complexity : O(n)

11. Inbuilt Search
    Use the find method to do a linear search inside array. 
    auto it = find(v.begin(), v.end(), target);
    int index = it - v.begin()

12. Rotate Image
    This problem can be broken down into 2 steps
    First take the transpose of the matrix

    for(int i=0; i<n; i++) {
        for(int j=0; j<n; j++) {
            if(i > j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }

    Then do a columnwise swapping

    for(int i=0; i<n/2; i++) {
        for(int j=0; j<n; j++) {
            swap(matrix[j][i], matrix[j][n-1-i]);
        }
    }

    Time Complexity : O(n^2)
    Space Complexity : O(1)

13. Set matrix zeroes
    First traverse the matrix and store all the pairs of row and cols which are zeroes.
    Now traverse the stored pairs and set each row and col to 0.
    (This however is not the most optimal solution)

    Time Complexity : O((n+m) * (n+m)) (In worst case)
    Space Complexity : O(n*m)

14. Two Sum
    Traverse the array and keep a hash map to keep track of all the visited elements inside the array. If you find an element
    such that another element exists inside the hash map and their sum is equal to target, return their indices.

    Time Complexity : O(n)
    Space Complexity : O(n)

15. Three Sum
    First sort the array, then traverse the array till the third last element and create 2 more pointers start and end
    which check the array for triplets for every outer for loop iteration. For some further optimisation add condition
    if(nums[i] == nums[i-1]) {continue} to avoid unnecessary duplicacy in computation. Add a while loop to the inner
    loop which moves the start and the end pointers to handle this same condition. It must be handled in both outer
    and inner loop.

    Time Complexity : O(n^2)
    Space Complexity : O(n)

16. Largest Mountain
    Traverse the array from 2nd to 2nd last element and find a peak element. Peak element is the element which is greater
    than both its neighbors. Then start running a while loop in left and right directions from that element keeping track 
    of count at every iteration. The count at the end is the length of the mountain, check if the current mountain length
    is greater than the one found so far.

    Time Complexity : O(n)
    Space Complexity : O(1)

17. Longest Consecutive Sequence
    Insert each element inside an unordered set. Now traverse the array and check if the current element starts a chain.
    Current element will start a chain if one lesser than that element does not ecist inside the set. Now once you have
    the beginning of the chain, keep checking for the next element inside the set and keep increasing the count by one.
    The count after the end of the loop is the length of the current chain you found. Update the global chain length with
    that length.

    Time Complexity : O(n)
    Space Complexity : O(n)

18. Rainwater Trapping
    First calculate the maximum till now left heights and store the values inside an array. Similarly calculate maximum
    till now right heights and store them inside an array. Now for each element do min(left, right) - curr_height to get
    the amount of water stored inside the current index. Add them all up and you will have the total water.

    Time Complexity : O(n)
    Space Complexity : O(n)

19. Subarray Sort
    First find the smallest and largest element which are out of order inside the array. Now traverse the array from
    left to right and find the index of element which is greater than the smallest element we found. Similarly traverse
    the array from right to left and find the index of element which is smaller than the largest element we found. These 
    2 indices denote the size of unsorted array that needs to be sorted in order for entire array to be sorted.

    Time Complexity : O(n)
    Space Complexity : O(n)

20. Minimum Swaps
    First create a copy of the array along with its indices in a new pair vector. Now sort this new vector. Now traverse 
    the array and maintain a visited array. If the element is already visited or is in its correct position skip that element.
    Otherwise start a cycle from that index and keep going to the index marked by the second element inside the pair vector
    and keep marking all indices as visited. Keep doing this until you reach the element which is visited. Add steps - 1
    to the total swaps variable you did for this entire routine. Return the total swaps at the end of the program.

    Time Complexity : O(logn) (Because of sorting)
    Space Complexity : O(n)

21. Minimum Difference
    First sort both the arrays. Now keep 2 pointers, one at the beginning of each array. Now keep calculating minimum difference.
    If the element in the first array is smaller increase the index of first array, if index in second array is smaller
    increase the index of second array. Keep calculating minimum difference at every step. Write a routine like the merge function.

    Time Complexity : O(n + m)
    Space Complexity : O(n)

22. Product of Array Except Self
    Create an array and calculate the prefix products for each element. Now keep a product variable initialized to 1 and
    start traversing the array in backwards direction and for every element in the new array mark current index as product
    of product variable and one perevious element in prefix array. Now mark product as product times current element inside
    the original array.

    Time Complexity : O(n)
    Space Complexity : O(n)

23. Min Arrows to burst Balloons (Busy Life)
    First sort the pair array according to the second coordinate in each points. Now save the first interval's end and traverse
    the array from the first index. Now if current start element is smaller than or equal to the previous ending element
    do nothing because all those balloon are overlapping and can be burst with one arrow only, otherwise increase the number 
    of arrows required by one. Return the total arrows required at the end of program.

    Time Complexity : O(n)
    Space Complexity : O(1)


Strings

1. Count Digits and Spaces
    Simply traverse the string and maintain two counts which are count_spaces and count_digits both initialised to 0.
    Whenever a space is encountered i.e current character == ' ' increase the count of spaces by one and whenever a 
    digit is encountered i.e cc >= '0' and cc <= '9' increase the count of digits by one and for letters do cc >= 'a'
    and cc <= 'z' && cc >= 'A' && cc <= 'Z'.

    Time Complexity : O(n)
    Space Complexity : O(1)

2. Find Shortest Path
    First calculate the total displacement in x and y direction. Now create an output empty string and if final x is less
    than 0 that means the movement was in east and if x was greater than 0 movement was in west. Similarly if final y 
    is less than 0 that means movement was in south and otherwise movement was in north.

    Time Complexity : O(n)
    Space Complexity : O(1)

3. Is Palindrome
    Traverse the array from start to middle, compare the ith element with (n-1-i)th element, if they are not equal return
    false. If the loop is terminated return true.

    Time Complexity : O(n)
    Space Complexity : O(1)

4. String Compression
    Maintain a count variable initialized to 1 and traverse till the second last index of the array. Check the condition
    whether current character is equal to next character. If it is, simply increase the count, otherwise place the current
    character at kth index and then check if the count id greater than 1. If it is, convert count to string and place 
    every character at next index after k. In the end return the k value which will be the length of the modified array.

    C++: to_string(x) converts number to string
    JS: String(x) converts number to string

    Time Complexity : O(n)
    Space Complexity : O(1)

5. Are Permutation
    First check if the strings are of unequal length. If they are simply return false. Now create a frequency vector of
    256 indices and store the character frequency of the first string in the vector. Now subtract the character frequency
    of the second string from the same vector. Now traverse the array, if a non zero element is found the strings were not
    permutations, otherwise they were.

    To convert character to ascii in Javascript use Character.charCodeAt(0) method
    Example: 'a'.charCodeAt(0) will give 97.

    Time Complexity : O(n)
    Space Complexity : O(1)

6. Remove Duplicates
    First sort the string. Now create an output empty string. Traverse the string till the second last element and 
    everytime you find a character not equal to the next character, append that character to the output string. 
    After exiting the loop append the last character of the string to the output string and return the output string.
    
    Time Complexity : O(nlogn)
    Space Complexity : O(n)

7. Vowel Find
    Traverse the string, check if the current character is a vowel and append it to output. Otherwise skip the current 
    character.

    Time Complexity : O(n)
    Space Complexity : O(n)

8. Binary String to Number
    Traverse the string from right to left and maintain a power variable initialised to 0 and a sum and do simple binary 
    arithmetic. Keep increase power at every step and return the result in the end.

    Time Complexity : O(n)
    Space Complexity : O(1)

9. Find Substring Index
    Its a good idea to use the find function to find the index of the substring inside a bigger string.
    int index = s.find(sub);
    int nextIndex = s.find(sub, index+1);
    If at any point index is -1, it means the substring was not found.

    For Javascript use the indexOf() method i.e haystack.indexOf(needle, index+1); index+1 can be 0

    Time Complexity : O(n)

10. Find All Occurences
    Repeatedly run the find function, first with the substring as the argument then with substring and index+1 as the
    second argument until a -1 is returned which indicates that substring is not found.

    Time Complexity : O(n)

11. Space20
    Traverse the character array and find the number of spaces and length of the current string. The length of the new
    string would be length of current string + 2 * number of spaces. Now keep 2 pointers one at the end of the original
    string and one at the end of the calculated length of the new string. Transfer all characters from i to jth index, if
    a space is encountered insert a %20 (3 characters) at the jth index to j-2th index and decrease index of j by 3.

    Time Complexity : O(n)
    Space Complexity : O(1)

12. String Tokenizer
    We can tokenize string using stringstream. Pass the string as an argument inside stringstream and initialize a token string.
    stringstream ss(s);
    string token;

    while(getline(ss, token, ' ')) {
        cout<<token<<" ";
    }

13. String Key Sort
    First tokenise the string vector. Now sort the tokens using a comparator according to column number. Then reform
    the strings.

    Time Complexity : O(nlogn)
    Space Complexity : O(1)

14. Check Subsets
    Traverse both the strings from back. If the current characters match, decrease the index of smaller string otherwise
    keep traversing the larger string in backwards direction. If at the end, index of the smaller string becomes -1
    the smaller string is subset of the larger string.

    Time Complexity : O(n)
    Space Complexity : O(1)

15. Sort Subsequences
    First simply generate substrings of a string then sort them with a comparator.

    Time Complexity : O(2^n)
    Space Complexity : O(2^n)

    An important piece of information here is that a subset and a subsequence are same things 
    (they can have break in elements, they can be non continuous) but a substring must be continuous
    Eg: "abc" -> "ac" can be a subsequence but not a substring

16. Digital Clock
    Just check minute conversion, if its single digit append a 0 and return in hh:mm format.

    Time Complexity : O(1)
    Space Complexity : O(1)

17. Biggest Number String
    Sort the numbers using a special comparator
    to_string(num1) + to_string(num2) > to_string(num2) + to_string(num1)
    Then append all the numbers inside the sorted list and return the string.

    Time Complexity : O(nlogn)
    Space Complexity : O(1)

18. Palindrome Break
    If the word is only one character, return an empty string. Otherwise traverse till the middle of the string, find
    a character which is not 'a', convert it to 'a' and return the string. If not such character is found, convert the 
    last character to a 'b' and return the string.

    Time Complexity : O(n)
    Space Complexity : O(1)

19. String normalization
    Requires more closer analysis.



Basic Sorting Algorithms

1. Bubble Sort
    Run an outer loop for n-1 iterations and the inner loop starting from 0 to n-1-i iterations for each i. Swap two adjacent
    elements if they are out of order everytime.

    Time Complexity : O(n^2)
    Space Complexity : O(1)

2. Insertion Sort
    Start traversing the array from first index and store the value of the current element. Now start a backwards 
    iteration from current index - 1 comparing each element with the current element and moving the index-1th element
    to the index until an element is found which is lesser than the current value. Now swap the current element with 
    one index ahead of that element's position. Keep doing this till the array is sorted.

    Time Complexity : O(n^2)
    Space Complexity : O(1)

3. Selection Sort
    Start traversing the array with the outer for loop starting from 0th index and inner for loop one greater than outer
    index. Let's say the element at the 0th index is the minimum element. Now if the inner for loop finds an element which
    is smaller than the ith element, store that index. After the inner loop finishes, swap the stored index with the ith
    index. Repeat until sorted.

    Space Complexity : O(n)
    Time Complexity : O(1)

4. Counting Sort
    Create a frequency vector of each element of the input array where index of the element is the element. Now traverse 
    the frquency vector and insert each element in the correct position in the input array.

5. Pair Sticks
    Sort the array and traverse the array using 2 pointers. For each element check if their difference is less than or
    equal to D. If it is increase the count by 1 and erase both elements from the array. Repeat the process until less 
    than 2 elements remain or no more pairs can be formed.

    Time Complexity : O(n^2)
    Space Complexity : O(1)

6. Defense Kingdom
    Create 2 arrays to hold x and y coordinates. Insert 0 to both to signify the start of the board and then insert all
    x and y coordinates to both arrays. Now insert width and height of board to x and y vectors. Now sort both arrays and 
    calculate maximum difference of x and y coordinates. Return (width - 1) * (height - 1).

    Time Complexity : O(nlogn)
    Space Complexity : O(n)


Two Dimensional Arrays

1. Spiral Print
    Declare 4 variables sr, sc, er and ec. Now run a while loop which checks for sr <= er && sc<= ec and then traverse
    the boundary. Now decrease boundary at the end of one iteration of while loop. Keep doing so until the loop ends.

2. Wave Print
    Traverse the last column of the matrix from top to bottom and then decrease the row and maintain a boolean variable
    which dictates the direction of traversal. After every traversal flip the variable and repeat until all columns are
    exhausted.

3. Staircase Search
    Initialize a pointer to the first row and last column. If the target number is smaller go left, if its larger go
    down, repeat until element is found or the pointer reaches out of bounds.


Sliding Window Problems

1. Housing
    The objective is to find out all the subarrays whose sum is equal to a target value. The elements will be positive.
    We create a window of size 0 with i and j initialised at index 0 and maintain a variable called cs = 0. Run a while
    loop with j < length of array and while cs is lesser than target keep expanding the window. Once cs exceeds target
    remove elements at the beginning. Now check if the cs is equal to the target and if it is, print the current window.

    Time Complexity: O(n)
    Space Complexity: O(1)

2. Maximum Substring with Unique Characters

    Create a hash map with charcter as a key and its index as a value. Traverse the string and at every index we will have
    two choices. Either the character does not exist inside the hash map or it does. The default step is to add it to the 
    hash table and increase the current window size by one and check the whether the current window size is greater than
    the max window size so far. If it is than set max_window_size to current window size and also set the start value to
    the i value. Before this check if the character exists inside the hash map and also the index inside the hash map is
    greater than i value (i.e the start of the current window). Now if it is set the i value to m[ch] + 1 and current length
    to j-i.

    Time Complexity O(n)
    Space Complexity O(n)

3. Minimum Window Substring

    The Objective is to find a minimum length substring inside the larger string which contains all the characters of the
    pattern string. To achieve this first create a frequency map FP for storing pattern string. Then create a map FS for
    storing the current window in question. Traverse the string, fill the FS map and maintain a variable called cnt. Now
    if the current character is present inside the pattern map and its frequncy inside the current window map is smaller
    or equal to the frequency inside the pattern map then increase cnt value by 1. 

    Now once the value of cnt is equal to the length of the pattern string, that means that all characters if the pattern
    exist inside the current window. So we will start removing characters from the beginning of the string or where our
    start pointer is placed. So if the character at start of the window does not exist inside the pattern map or its
    frequency inside the window map is greater than frequncy inside the pattern map, remove that element from the window
    map and increase the value of start. Keep repeating and check the current window size and compare with minimum size
    found so far. Also update the value of the window_start variable which is initialised with -1 which denotes the start
    index of the minimum window found so far.

    Time Complexity: O(n)
    Space Complexity: O(1)

4. Smallest Distinct Window
    This is exactly the same as maximum substring with unique characters.

5. Count subarrays with target sum
    This is a modification of the housing problem with negative numbers also existing inside the array. Create a prefix
    array and a hashmap which contains prefix sum as key and its frequency as value. Insert the first element of the array
    and set its value as 1. Traverse the array and fill the prefix index, then check if prefix[index]-k exists inside the
    map. If it does add its value to the count. Check another condition whether prefix[index] itself is equal to target.
    That means that starting from 0 index to current index sum of values is equal to target sum, add count+1 if this is true.
    Return the count at the end of the loop.


Binary Search

    1. Frequency Count
    
    First find the lower bound index of an element. To do that run the standard binary search routine
    but also maintain an extra variable called result initialised with -1. Whenever the target element is found, set the 
    result as that index and search in the left half. Keep doing this until convergence and lower bound will be acquired.
    Similarly find the uper bound but search in the right direction instead. Frequency count will be hi-lo+1.

    Time Complexity: O(logn)
    Space Complexity: O(1)

    2. Rotated Search

    Run a standard binary search routine but modify it as following. Check whether mid is the element, if it is then return
    mid as the answer otherwise there will be 2 cases. Either the mid lies on the first line or the second line.

    To check if the mid lies on the first line simply do arr[start] <= arr[mid] else the second line.
    If the mid lies on the first line, now check whether the target lies on the left hand side of the first line or right
    hand side. To check if the target lies on the left side simply check if arr[start] <= arr[target] and arr[target] <= arr[mid]
    and shift the end pointer to mid-1. Otherwise shift start to mid+1.

    If the mid lies on the second line check whether the target lies on the right hand side of the second line. Do this by
    checking if target >= arr[mid] && target <= arr[end]. If the target lies on the right side do start = mid + 1 otherwise
    end = mid - 1.

    Time Complexity : O(logn)
    Space Complexity : O(1)

    3. Square Root

    The objective is to find the square root of a number to a certain precision P. First run a simple binary search to find
    the first digit of the square root. Then inside a for loop which runs till P, run another loop which goes to a max value
    of 10 and keeps adding a factor to the result. If result times result becomes greater than result break the inner loop and
    subtract one factor value from the result.

    Time Complexity : O(logn + P)
    Space Complexity : O(1)

    4. Angry Birds

    Given N number of nests and B birds, we have to place these B birds on the nests such that no two birds are on the same
    nest and the separation between the birds is the maximum possible separation. This problem can be solved using binary search
    by modifying the search space. First sort the nests array and set lo as 0 and hi as the nest at the last index. Now run
    a binary search and check whether B birds can be placed on all the nests with a minimum separation of mid. If they can
    then set the result as mid and reduce the search space to mid + 1 and hi and if they cannot be placed then reduce the 
    search space in the left direction that is lo to mid-1 and do not update the result in this case. Keep updating and finding
    the maximum possible value of result and return it in the end.

    Time Complexity: O(nlogn + nlogm) where m is the maximum element inside the nests array 
    Space Complexity: O(1)

    5. Minimum Pairs

    Sort the second array and search for the lower bound of each value in the first array. The lower bound function will
    give the element in the second array which is just larger than the element in the first array. Now for every element 
    we will compare it with the element at the lower bound index and one previous element, calculate the difference and
    update some global variables. Make sure to handle some edge cases where lb-1 is greater than or equal to zero and the
    one where lb is lesser than size of array.

    Time Complexity: O(MlogM + NlogM) where N and M are the size of the first and second array respectively
    Space Complexity: O(1)

    6. Game of Greed

    The objective is to divide coins among k friends such that the first k-1 friends pick up the largest divisions and the 
    last friend remaining picks up the smallest division and that division is maximum possible. To do this create a search
    space of lo = 0 and hi  = sum of all coins. Now for every mid in binary search check if the distribution can be made, if
    it can then set lo to mid +1 and res to mid otherwise search in the left searchspace.

    Time Complexity: O(N * log(sum(N)))
    Space Complexity: O(1)

Basic Sorting Algorithms

    1. Bubble Sort

    Run the outer loop for n-1 times and the inner loop from 0 to n-1-times and keep swapping adjacent elements is the current
    element is larger than the next element. Every time the inner loop decreases by one since the elements keep going in their
    correct place after every inner loop iteration.

    Time Complexity : O(n * n)
    Space Complexity : O(1)

    2. Insertion Sort

    Run the outer loop from first index to last index and inside the loop traverse backwards and check if the element is larger
    than the current element, i.e the element marked by the outer loop. If it is keep replacing the next element with the
    element marked by inner iterator and once an element smaller than current is found replace the one next to it with the
    current element.

    Time Complexity : O(n * n)
    Space Complexity : O(1)

    3. Selection Sort

    For every element till the second last find the element in the res of the array which is smaller than it and save its index.
    Once the smallest index is found, replace it with the current element's index. Keep repeating until array is sorted.

    Time Complexity : O(n * n)
    Space Complexity : O(1)

    4. Counting Sort

    Find the largest element and create a new temporary array with its size. Now traverse the original array and at the index
    pointed by the element increase the count in the temp array. Now traverse the temp array and while an element is graeter
    than 0 keep adding that index to the original array while also incresing the index of the original array and decreasing the
    current element inside temporary array by 1.

    Time Complexity : O(largest + N)
    Space Complexity : O(largest)

    5. Pairing Sticks

    The objective is to find total pairs of sticks whose difference per pair is at most D. So sort the array and run two nested
    loops outer starting from 0 to n-2 and inner from outer+1 to n-1. Now check each pair's difference and if they satisfy the
    criteria increment the total by 1 and set both of them to INT_MAX as they cannot be used further. Do not consider INT_MAX
    values when finding the difference. 

    Time Complexity : O(n * n)
    Space Complexity : O(1)

    6. Defense Kingdom

    The objective is to find the largest area cpatured by the castles. So first collect the x and y coordinates from the 
    given pair array. Push 0 to the front of both and W+1 to the x array and H+1 to the y array. Now sort both the arrays. 
    Now find the largest difference of two consecutive elements in both the arrays. Subtact one from each and multiply them
    and that will be the result.

    Time Complexity : O(nlon + mlogm)
    Space Complexity : O(n + m)


Dynamic Programming

    Optimal Substructure: Optimal Substructure means a problem can be solved by breaking it into subproblems and combining
    the solutions of the subproblems.

    Overlapping Subproblems: Subproblems which are being computed again and again.

    1. NK Ladders 
        Problem is that starting from 0 and taking anuywhere from 1 to k steps at a time, how many ways are there to reach the
        Nth step.

        Recursive Solution: Start from N and run a loop from 1 to K. Call the function inside every iteration of the loop.
        subtracting the i value from N. Maintain an ans varable initialised at the top to 0 and add the result of every 
        recursive call to the ans. The return the ans outside the loop. Base case will be if 0 is reached then return 1 as
        that is a valid way, if < 0 then return 0. This is like an enhanced version of fibonacci but the base case is
        slightly different.

        Time Complexity : O(2 ^ n)
        Space Complexity: O(2 ^ n)

        Bottom Up: Create a dp array of size N+1, initialize 0 index with 1 and add previous k values to the current cell.

        Time Complexity : O(N * k)
        Space Complexity : O(N)

        Bottom Up Optimised : Create an array of N+1 length and initialize 0 index with 1. For every cell i the result
        will be 2 * dp[i-1] - d[i-k-1]. For the first k cells the answer for each cell i would be simply 2 * dp[i-1].

        So first run a loop for 0 to k and then k+1 to N.

        Time Complexity : O(N)

    2. Coin Change (Coin Change I)

        The objective is to find the minimum number of coins required to create a given amount. The recursive definition
        can be written as for all coins in denominations subtract the current coin from the amount and calculate the min
        coins required for creating the amount currentAmount - coins[i], and do the same for all coins and find out the
        minimum result among all of them and add one to it. If the amount is 0 which is the base case then return 0 since
        0 coins are required to make 0 amount. Also make sure that call is not being made to an amount lesser than 0.

        Time Complexity O(C^N) where C are coins and N is amount

        In the Bottom Up Approach, create an array of size amount+1. First set the current index to INT_MAX and then for every
        index starting 1 check all the coins required to make that amount(index). If index - coin  >= 0 only consider the 
        coin and check the value of dp array at that index, if its not INT_MAX then  add one to that amount and take a minimum
        with current value of dp[i]. Do so for all of the coins and in the end check the value of last index, if its INT_MAX
        return -1 as creating that value would be impossible otherwise return the value.

        Time Complexity O(N * C) where C are total coins and N is the amount.


    3. Rod Cutting:

        Find the maximum profit that can be obtained by cutting a rod of length N into multiple pieces. Price of each piece is
        given. The recursive solution is to run a loop from 0 to N and make a cut of length i+1 on the rod. Add the price of the
        current cut and recursively calculate the price of the remaining rod. If rod length becomes 0 return 0 as the base case.
        Now for all the cuts check the max profit obtained for all the cut prices and their respective subproblems.

        For the bottom up solution first create a dp array of length N+1 and initialize dp[0] to 0. Now run a loop for length 1
        to N and run an inner loop for j equals 0 to j lesser than len. Now the cut would be of length j+1. So Add the price
        of j and dp[len-cut] and keep doing so for all the cuts while maintaining a max value and at the end of the inner loop
        set the current dp[len] to that value. Return dp[N] at the end of the function.

        Time Complexity: O(N^2)
        Space Complexity: O(N)

    4. Minimum Jumps:

        Given an array whose indices denote maximum jump you can take at that index. Return the minimum jumps needed to reach the 
        last index. Recursively this problem can be broken down as follows, starting from jump = 1 to jump = arr[idx] add 1 + 
        function call at the jump + idx index and find the 1 + minimum of all those recursive calls. In the base case if the last
        index is reached return 0, and if array boundary is exceeded return INT_MAX. While checking for subproblems check if
        a subproblem returns an INT_MAX and if it does do not consider it while calculating the min jumps. 

        For the bottom up approach traverse the array from n-2th index to 0. For each index calculate what will be the minimum
        amount of jumps to get from there till end by running an inner loop which checks from jump = 1 to jump = arr[i].
        Take the minimum of all possible results.

    5. Longest Common Subsequence: 
    Important: Initialize 2D DP array with -1 since 0 could be a valid answer during TD code.

    Objective is to find the maximum length of the common subsequence between two strings. In recursive or top down approach
    initialize both the strings from i=0 and j=0 and check if the charcter at both the strings match. If it does then add 1
    to the recursive call on the remaining both strings from i+1 and j+1. If they do not match at the current indices then
    find the max of i+1 of the first string and j+1 of the second string and return it. In the base case if i or j reach end
    of their respective strings then simply return 0. Please note during memoisation of TD Solution, Initialise the array with
    -1 values as 0 can also be a valid answer.

    In the Bottom Up Approach create an array of s1.size()+1 and s2.size()+1 dimensions and the first row and column should
    be initialised with 0 as i=0 and j=0 denote empty strings and act as base cases. Now traverse the 2d array from 1 based 
    indexing and if the current charcter matches add 1 to the result stored in the left upper diagonal(i-1, j-1) and if they
    do not match then store the maximum of the cells directly above and to the left max(dp(i-1, j) and dp(i, j-1)).
    The final answer will be stored at the last index. 

    If we want to generate the string we must start tracing the array from the last index. If the value of the current index
    matches with the one directly above then move the pointer to directly above and if the value matches to the index directly
    on the left, move the pointer to left and if they don't then the current indices should match, add the character to the
    output and move to i-1 and j-1.


Queues
    1. First Non Repeating Letter
        We are given an input stream of characters and we have to tell the first non repeating character for every single 
        index inside the input stream. The algorithm to do so is as follows:

        Create a hash map (frequency map) and a queue Traverse over the string and add the character to the map and push it 
        to the queue. Now check every single character starting from the front of the queue and if its frquency is greater
        than 1 inside the map, remove that character. Do so until the queue is empty or the first character inside the queue
        has frequency equal to 1. If the queue is empty print a -1 otherwise print the first character of the queue.

Heaps
    For the running median, 3 overall cases (comparing heap sizes) and 2 cases for each of them.


